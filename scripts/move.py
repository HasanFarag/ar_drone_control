#!/usr/bin/env python
import rospy
from std_msgs.msg import Empty
from std_msgs.msg import Bool
from geometry_msgs.msg import Twist

import numpy as np


class TrajectoryGenerator():
    def __init__(self, start_pos, des_pos, T, start_vel=[0, 0, 0], des_vel=[0, 0, 0], start_acc=[0, 0, 0], des_acc=[0, 0, 0]):
        self.start_x = start_pos[0]
        self.start_y = start_pos[1]
        self.start_z = start_pos[2]

        self.des_x = des_pos[0]
        self.des_y = des_pos[1]
        self.des_z = des_pos[2]

        self.start_x_vel = start_vel[0]
        self.start_y_vel = start_vel[1]
        self.start_z_vel = start_vel[2]

        self.des_x_vel = des_vel[0]
        self.des_y_vel = des_vel[1]
        self.des_z_vel = des_vel[2]

        self.start_x_acc = start_acc[0]
        self.start_y_acc = start_acc[1]
        self.start_z_acc = start_acc[2]

        self.des_x_acc = des_acc[0]
        self.des_y_acc = des_acc[1]
        self.des_z_acc = des_acc[2]

        self.T = T

    def solve(self):
        A = np.array(
            [[0, 0, 0, 0, 0, 1],
             [self.T**5, self.T**4, self.T**3, self.T**2, self.T, 1],
             [0, 0, 0, 0, 1, 0],
             [5*self.T**4, 4*self.T**3, 3*self.T**2, 2*self.T, 1, 0],
             [0, 0, 0, 2, 0, 0],
             [20*self.T**3, 12*self.T**2, 6*self.T, 2, 0, 0]
             ])

        b_x = np.array(
            [[self.start_x],
             [self.des_x],
             [self.start_x_vel],
             [self.des_x_vel],
             [self.start_x_acc],
             [self.des_x_acc]
             ])

        b_y = np.array(
            [[self.start_y],
             [self.des_y],
             [self.start_y_vel],
             [self.des_y_vel],
             [self.start_y_acc],
             [self.des_y_acc]
             ])

        b_z = np.array(
            [[self.start_z],
             [self.des_z],
             [self.start_z_vel],
             [self.des_z_vel],
             [self.start_z_acc],
             [self.des_z_acc]
             ])

        self.x_c = np.linalg.solve(A, b_x)
        self.y_c = np.linalg.solve(A, b_y)
        self.z_c = np.linalg.solve(A, b_z)


class drone(object):

    def __init__(self):
        self.take_off_pub = rospy.Publisher(
            '/drone/takeoff', Empty, queue_size=10)
        self.land_pub = rospy.Publisher('/drone/land', Empty, queue_size=10)
        self.posctrl_pub = rospy.Publisher(
            '/drone/posctrl', Bool, queue_size=10)
        self.cmd_vel_pub = rospy.Publisher(
            '/drone/cmd_val', Twist, queue_size=10)
        self.bool = Bool()
        self.bool.data = True
        self.cmd_vel = Twist()
        rospy.loginfo('drone started working')

    def takeoff(self):
        start = rospy.get_time()
        while (rospy.get_time()-start) < 0.5:
            self.take_off_pub.publish(Empty())
        rospy.loginfo('drone take_off')
        rospy.sleep(2.0)

    def land(self):
        start = rospy.get_time()
        while (rospy.get_time()-start) < 0.5:
            self.land_pub.publish(Empty())
        rospy.loginfo('drone land')
        rospy.sleep(2.0)

    def posctrl(self):
        start = rospy.get_time()
        while (rospy.get_time()-start) < 0.5:
            self.posctrl_pub.publish(self.bool)
        rospy.loginfo('drone posctrl')
        rospy.sleep(1.0)

    def pose_move(self, vx=0.0, vy=0.0, vz=0.0, wx=0.0, wy=0.0, wz=0.0):
        start = rospy.get_time()
        self.cmd_vel.linear.x = vx
        self.cmd_vel.linear.y = vy
        self.cmd_vel.linear.z = vz
        self.cmd_vel.angular.x = wx
        self.cmd_vel.angular.y = wy
        self.cmd_vel.angular.z = wz
        while (rospy.get_time()-start) < 0.5:
            self.cmd_vel_pub.publish(self.cmd_vel)
        print 'drone desired pose is %s' % self.cmd_vel
        rospy.sleep(3.0)

    def calculate_position(self, c, t):
        """
        Calculates a position given a set of quintic coefficients and a time.
         Args
        c: List of coefficients generated by a quintic polynomial 
            trajectory generator.
        t: Time at which to calculate the position
        Returns
        Position
        """
        return c[0] * t**5 + c[1] * t**4 + c[2] * t**3 + c[3] * t**2 + c[4] * t + c[5]


if __name__ == "__main__":

    rospy.init_node('drone')
    drone = drone()
    # rate = rospy.Rate(10) # 10hz

    drone.posctrl()
    drone.takeoff()
    drone.pose_move(0.0, 0.0, 0.5)
    drone.pose_move(0.0, -0.1945, 0.5)
    drone.pose_move(3.0, -0.1945, 0.5)
    waypoints = [[4.5, 0.3035, 1.18], [3.1, 0.3035, 0.5], [3.1, 0.0545, 0.5], [
        4.6, 0.0545, 1.18], [4.6, -0.1945, 1.18], [3.1, -0.1945, 0.5]]
    n_run = 6
    dt = 1.0  # 0.1
    t = 0
    i = 0
    n_run = 6
    irun = 0
    T = 5  # waypoint time 5
    x_coeffs = [[], [], [], [], [], []]
    y_coeffs = [[], [], [], [], [], []]
    z_coeffs = [[], [], [], [], [], []]
    for i in range(0, 6):
        traj = TrajectoryGenerator(waypoints[i], waypoints[(i + 1) % 6], T)
        traj.solve()
        x_coeffs[i] = traj.x_c
        y_coeffs[i] = traj.y_c
        z_coeffs[i] = traj.z_c
    while True:
        while t <= T:
            des_x_pos = drone.calculate_position(x_coeffs[i], t)
            #des_y_pos = drone.calculate_position(y_coeffs[i], t)
            des_z_pos = drone.calculate_position(z_coeffs[i], t)
            t += dt
            drone.pose_move(des_x_pos[0], waypoints[i][1], des_z_pos[0])
            rospy.sleep(dt)

        t = 0
        i = (i + 1) % 6
        irun += 1
        if irun >= n_run:
            break

    # drone.pose_move(3.1,-0.1945,0.5)

    #drone.pose_move(3.45,-0.1945, 0.67)
    #drone.pose_move(3.8,-0.1945, 0.84)
    #drone.pose_move(4.15,-0.1945, 1.01)

    #drone.pose_move(3.55,-0.1945, 0.67)
    #drone.pose_move(3.9,-0.1945, 0.84)
    #drone.pose_move(4.25,-0.1945, 1.01)

    #drone.pose_move(4.6,-0.1945, 1.18)
    #drone.pose_move(4.6,0.0545, 1.18)

    #drone.pose_move(4.25,0.0545, 1.01)
    #drone.pose_move(3.9,0.0545, 0.84)
    #drone.pose_move(3.55,0.0545,  0.67)

    #drone.pose_move(3.1,0.0545, 0.5)
    # drone.pose_move(3.1,0.3035,0.5)

    #drone.pose_move(3.55,0.3035, 0.67)
    # drone.pose_move(3.9,0.3035,0.84)
    #drone.pose_move(4.25,0.3035, 1.01)

    #drone.pose_move(4.5,0.3035, 1.18)

    drone.pose_move(4.5, 0.3035, 1.3)

    drone.pose_move(0.0, 0.0, 0.0)

    ###############################

    # drone.pose_move(0.0,0.0,0.5)

    # drone.pose_move(0.0,-0.1945,0.5)

    # drone.pose_move(3.0,-0.1945,0.5)
    # drone.pose_move(3.1,-0.1945,0.5)

    ##drone.pose_move(3.45,-0.1945, 0.67)
    ##drone.pose_move(3.8,-0.1945, 0.84)
    ##drone.pose_move(4.15,-0.1945, 1.01)

    #drone.pose_move(3.55,-0.1945, 0.67)
    #drone.pose_move(3.9,-0.1945, 0.84)
    #drone.pose_move(4.25,-0.1945, 1.01)

    #drone.pose_move(4.6,-0.1945, 1.18)
    #drone.pose_move(4.6,0.0545, 1.18)

    #drone.pose_move(4.25,0.0545, 1.01)
    #drone.pose_move(3.9,0.0545, 0.84)
    #drone.pose_move(3.55,0.0545,  0.67)

    #drone.pose_move(3.1,0.0545, 0.5)
    # drone.pose_move(3.1,0.3035,0.5)

    #drone.pose_move(3.55,0.3035, 0.67)
    # drone.pose_move(3.9,0.3035,0.84)
    #drone.pose_move(4.25,0.3035, 1.01)

    #drone.pose_move(4.5,0.3035, 1.18)
    #drone.pose_move(4.5,0.3035, 1.3)

    # drone.pose_move(0.0,0.0,0.0)
    drone.land()

    # rate.sleep()
    try:
        rospy.spin()
    except KeyboardInterrupt:
        print("Shutting down")
